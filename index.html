<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>情緒煉金術 2.0 - 粒子生命</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: radial-gradient(circle at center, #1a1a2e 0%, #050505 100%); overflow: hidden; color: #fff; }
        #ui-layer { pointer-events: none; }
        .interactive { pointer-events: auto; }
        canvas { filter: contrast(120%) brightness(110%); }
    </style>
</head>
<body class="flex flex-col items-center justify-end h-screen">

    <canvas id="canvas" class="absolute inset-0 w-full h-full"></canvas>

    <div id="ui-layer" class="relative w-full max-w-lg p-8 mb-10 flex flex-col items-center">
        <div id="msg" class="text-indigo-300 text-sm mb-4 opacity-0 transition-opacity duration-1000">正在萃取情緒養分...</div>
        
        <div class="interactive w-full bg-black/40 backdrop-blur-xl border border-white/10 rounded-3xl p-6 shadow-[0_0_50px_rgba(0,0,0,0.5)]">
            <textarea id="input" 
                class="w-full bg-transparent border-none focus:ring-0 text-lg placeholder-indigo-900/50 resize-none h-20 text-indigo-100" 
                placeholder="傾倒你的秘密、憤怒或壓力..."></textarea>
            
            <div class="flex justify-end mt-4">
                <button onclick="ignite()" 
                    class="bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white px-8 py-3 rounded-2xl font-bold shadow-lg shadow-indigo-500/20 transition-all active:scale-95">
                    賦予生命
                </button>
            </div>
        </div>
    </div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width, height;
let branches = [];

// 初始化畫布尺寸
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

class Branch {
    constructor(x, y, angle, speed, life, color, width) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = speed;
        this.life = life;
        this.initialLife = life;
        this.color = color;
        this.w = width;
    }

    update() {
        // 核心進化：隨機擾動（模擬風與生命感）
        this.angle += (Math.random() - 0.5) * 0.2;
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.life--;
        this.w *= 0.98; // 越長越細

        // 渲染粒子
        ctx.beginPath();
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.w;
        ctx.lineCap = 'round';
        ctx.shadowBlur = this.initialLife / 5;
        ctx.shadowColor = this.color;
        ctx.moveTo(this.x - Math.cos(this.angle)*this.speed, this.y - Math.sin(this.angle)*this.speed);
        ctx.lineTo(this.x, this.y);
        ctx.stroke();

        // 分裂邏輯：根據壓力深度決定分支機率
        if (this.life > 0 && Math.random() < 0.05 && this.w > 1) {
            branches.push(new Branch(this.x, this.y, this.angle + 0.4, this.speed * 0.9, this.life * 0.8, this.color, this.w));
            branches.push(new Branch(this.x, this.y, this.angle - 0.4, this.speed * 0.9, this.life * 0.8, this.color, this.w));
            return false;
        }
        return this.life <= 0;
    }
}

function ignite() {
    const text = document.getElementById('input').value;
    if (!text) return;

    const msg = document.getElementById('msg');
    msg.style.opacity = 1;

    // 進化版情緒算法
    // 1. 根據字數決定高度 (Life)
    // 2. 根據語氣標點決定色彩 (Hue)
    // 3. 根據輸入速度決定生長速度 (Speed)
    const stressScore = Math.min(text.length, 100);
    const hue = (text.includes('!') || text.includes('幹')) ? 0 : (200 + Math.random() * 60); // 憤怒變紅，憂鬱變藍
    const color = `hsla(${hue}, 80%, 60%, ${Math.random() * 0.5 + 0.5})`;

    // 從底部向上噴發粒子
    for(let i=0; i<3; i++) {
        branches.push(new Branch(
            width / 2, 
            height, 
            -Math.PI / 2 + (Math.random()-0.5), 
            2 + Math.random() * 3, 
            50 + stressScore, 
            color, 
            5 + (stressScore/10)
        ));
    }

    document.getElementById('input').value = '';
    setTimeout(() => msg.style.opacity = 0, 3000);
}

function animate() {
    // 這裡不清理畫布，形成生長軌跡
    // 但加入極淡的半透明層，產生緩慢消散的視覺流動感
    ctx.fillStyle = 'rgba(5, 5, 5, 0.02)';
    ctx.fillRect(0, 0, width, height);

    branches = branches.filter(b => !b.update());
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
